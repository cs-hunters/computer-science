\## 네트워크

### 1\. 쿠키와 세션의 차이에 대해 설명해 주세요.
> - 쿠키와 세션은 HTTP의 Stateless 특성을 보완하기 위해 상태를 유지하는 방식입니다.쿠키는 클라이언트 저장 방식이라 가볍지만 보안이 약하고, 세션은 서버 저장 방식이라 안전하지만 확장성이 떨어집니다.
> * 쿠키는 클라이언트, 즉 브라우저에 저장되는 작은 데이터 조각입니다. 서버가 응답 시 Set-Cookie 헤더를 통해 전달하며, 브라우저는 이후 요청마다 Cookie 헤더에 해당 값을 포함해 전송합니다. 쿠키 방식은 서버 부담이 적지만, 데이터가 클라이언트에 그대로 노출되므로 변조나 탈취 위험이 있어 보안이 약합니다.
> * 반대로 세션은 서버 측에서 사용자 상태를 관리합니다. 클라이언트는 세션 ID만 쿠키나 URL 파라미터를 통해 전달하고, 실제 데이터는 서버 메모리나 Redis 같은 세션 스토리지에 보관됩니다. 세션 방식은 보안성이 높지만 서버 자원을 소모하고, 서버가 여러 대일 경우 세션 동기화나 공유 문제를 해결해야 한다는 단점이 있습니다.

*   세션 방식의 로그인 과정에 대해 설명해 주세요.
> (1) 사용자가 로그인 요청을 보냄.
> (2) 서버가 사용자 인증에 성공하면 세션 객체를 생성하고, 고유한 세션 ID를 발급.
> (3) 세션 ID를 클라이언트에 쿠키로 저장.
> (4) 이후 요청마다 세션 ID를 포함해 전송하면, 서버가 세션 저장소에서 사용자 정보를 조회해 상태를 복원.


*   HTTP의 특성인 Stateless에 대해 설명해 주세요.
> - HTTP는 Stateless Protocol입니다. 각 요청과 응답은 독립적으로 처리되며, 서버는 이전 요청의 상태를 기억하지 않습니다. 클라이언트가 한 번 요청을 보냈다고 해서, 서버가 그 사용자의 상태나 맥락을 자동으로 보존하지 않는다는 의미입니다.

*   Stateless의 의미를 살펴보면, 세션은 적절하지 않은 인증 방법 아닌가요?
> - HTTP는 Stateless한 프로토콜이기 때문에 본질적으로 상태를 유지하지 않습니다. 따라서 세션 방식은 이 특성에 반하지만, 매번 인증을 요구하면 사용자 경험이 크게 저하될 수 있습니다.
실제 웹/앱 서비스에서는 편의성과 보안성을 위해 서버가 클라이언트의 상태 정보를 세션에 저장하는 방식을 사용하기도 합니다. 

*   규모가 커져 서버가 여러 개가 된다면, 세션을 어떻게 관리할 수 있을까요?
> - 서버가 수평 확장-> 각 서버가 세션을 따로 보관하면 불일치가 발생하기 때문에 세션 스티키, 세션 복제, 또는 Redis 같은 외부 저장소가 필요합니다.


### 2\. HTTP 응답코드에 대해 설명해 주세요.

HTTP 응답코드는 클라이언트 요청에 대한 서버의 처리 결과를 나타내며, 5가지 클래스로 구분됩니다.

1xx: Informational (정보) 요청을 수신했으며, 처리 중임을 의미.

2xx: Success (성공) 요청이 성공적으로 처리됨.
200 OK – 일반적인 성공.
201 Created – 리소스가 새로 생성됨.
204 No Content – 요청 성공했지만 응답 본문 없음.

3xx: Redirection (리다이렉션) 추가 동작(다른 URI 요청)이 필요함.
301 Moved Permanently – 영구적으로 이동.
302 Found – 일시적으로 이동.
304 Not Modified – 캐시된 리소스 사용 가능.

4xx: Client Error (클라이언트 오류) 클라이언트 요청에 문제가 있음.
400 Bad Request – 잘못된 요청.
401 Unauthorized – 인증 필요 또는 실패.
403 Forbidden – 인증은 되었지만 권한 없음.
404 Not Found – 리소스를 찾을 수 없음.

5xx: Server Error (서버 오류)
서버가 요청을 처리하지 못함.
500 Internal Server Error – 일반적 서버 오류.
502 Bad Gateway – 게이트웨이/프록시 오류.
503 Service Unavailable – 서버 과부하/점검.
504 Gateway Timeout – 게이트웨이 시간 초과.


*   401 (Unauthorized) 와 403 (Forbidden)은 의미적으로 어떤 차이가 있나요?
> * 401 Unauthorized: 인증(Authentication)이 필요하지만 제공되지 않았거나, 제공된 자격 증명이 유효하지 않음. → 인증 실패.
> * 403 Forbidden: 인증은 성공했지만 해당 리소스에 접근 권한(Authorization)이 없음. → 권한 부족.

*   200 (ok) 와 201 (created) 의 차이에 대해 설명해 주세요.
> 200 OK: 요청이 성공적으로 처리됨. 주로 조회(GET) 요청이나 일반 처리 결과 반환 시 사용.
> 201 Created: 요청으로 인해 새로운 리소스가 생성되었음을 의미. RESTful API에서 POST 요청 후 생성된 리소스의 URI를 Location 헤더에 담아 응답하는 것이 일반적.

*   필요하다면 저희가 직접 응답코드를 정의해서 사용할 수 있을까요? 예를 들어 285번 처럼요.
> 표준 이외의 커스텀 코드로 사용 가능하지만, 클라이언트/라이브러리 호환성과 표준성 측면에서 권장되지 않는다. 대신 200 OK + 커스텀 에러 메시지 바디(JSON) 형태로 정의하는 것이 일반적이다.

### 3\. HTTP Method 에 대해 설명해 주세요.
HTTP Method는 클라이언트가 서버 리소스에 대해 **어떤 행위(Intent)**를 요청하는지를 표현하는 수단입니다. 즉, 리소스 자체가 아니라 **행위(동작)**를 명시하는 것이 핵심입니다. 같은 URI라도 Method에 따라 의미와 처리 방식이 달라집니다. HTTP Method는 단순한 요청 구분이 아니라, RESTful API 설계에서 리소스를 조작하는 표준화된 인터페이스라고 할 수 있습니다.

GET: 리소스 조회 (안전, 멱등).
POST: 리소스 생성 혹은 처리 요청 (비멱등).
PUT: 리소스 전체 교체 (멱등).
PATCH: 리소스 일부 수정 (비멱등).
DELETE: 리소스 삭제 (멱등).
HEAD: 리소스의 메타데이터만 조회.
OPTIONS: 서버가 지원하는 메서드 및 CORS 정책 확인.


*   HTTP Method의 멱등성에 대해 설명해 주세요.
> 멱등성이란 같은 요청을 여러 번 반복해도 서버의 최종 상태가 변하지 않는 성질을 말합니다. 이는 서버 자원의 일관성과 안전한 재시도를 보장하는 중요한 개념입니다.

HTTP Method별 멱등성 여부:

Method	멱등성 여부	설명
GET	O	조회만 수행 → 서버 상태 변화 없음
HEAD	O	응답 헤더만 반환 → 상태 변화 없음
PUT	O	동일한 리소스로 전체 교체 → 여러 번 호출해도 결과 동일
DELETE	O	같은 리소스 삭제 요청 반복 시 최종 상태 동일
OPTIONS	O	서버 지원 메서드 질의용 → 상태 변화 없음
TRACE	O	요청을 그대로 반환 → 상태 변화 없음
POST	✗	요청마다 새로운 리소스 생성 가능 → 상태 달라짐
PATCH	보장되지 않음	일부 수정이므로 연산 정의에 따라 멱등/비멱등 달라짐


*   GET과 POST의 차이는 무엇인가요?
> * GET은 서버의 리소스를 조회할 때 사용하고, 요청 데이터는 URL 쿼리 스트링으로 전달됩니다. 멱등적이고 캐싱이 가능하지만, 데이터가 URL에 노출되기 때문에 보안상 민감 정보에는 적절하지 않습니다.
> * POST는 리소스를 생성하거나 처리할 때 사용하며, 데이터가 HTTP Body에 담겨 전송됩니다. 비멱등적이고 기본적으로 캐싱되지 않으며, GET보다 보안상 안전하지만 반드시 HTTPS를 통해 보호하는 것이 중요합니다.

*   POST와 PUT, PATCH의 차이는 무엇인가요?
> * POST는 주로 새로운 리소스를 생성하거나 서버에 어떤 동작을 요청할 때 사용합니다. 비멱등이기 때문에 같은 요청을 여러 번 보내면 리소스가 중복 생성될 수 있습니다.
> * PUT은 특정 리소스를 전체 교체하는 용도로 쓰이며, 멱등적이라 동일한 요청을 반복해도 결과가 변하지 않습니다.
> * PATCH는 리소스의 일부만 수정하는 데 사용되고, 부분 업데이트를 지원한다는 점에서 PUT과 구분됩니다. 멱등성이 보장되지 않습니다.

*   HTTP 1.1 이후로, GET에도 Body에 데이터를 실을 수 있게 되었습니다. 그럼에도 불구하고 왜 아직도 이런 방식을 지양하는 것일까요?

### 4\. HTTP에 대해 설명해 주세요.

*   공개키와 대칭키에 대해 설명해 주세요.
*   왜 HTTPS Handshake 과정에서는 인증서를 사용하는 것 일까요?
> HTTPS Handshake에서 인증서는 신원 검증과 보안 채널 수립을 동시에 달성하기 위한 장치입니다. 두 가지 핵심 이유가 있습니다.
첫째, 서버가 주장하는 도메인이 실제로 신뢰할 수 있는 주체임을 보장합니다. 인증서는 공인된 CA의 서명을 통해 위조 여부를 검증할 수 있기 때문에 중간자 공격을 방지합니다.
둘째, 안전한 키 교환을 가능하게 합니다. 클라이언트는 인증서에 포함된 서버의 공개키를 사용해 세션키를 안전하게 전달하고, 이후에는 성능이 좋은 대칭키 암호화를 사용해 통신합니다.

*   SSL과 TLS의 차이는 무엇인가요?

### 5\. 웹소켓과 소켓 통신의 차이에 대해 설명해 주세요.
> - 소켓은 네트워크 상에서 프로세스 간 통신을 위한 프로그래밍 인터페이스(API)로, 운영체제에서 제공하는 네트워크 통신의 추상화된 개념입니다.
> - 웹소켓은 HTTP를 기반으로 하는 양방향 통신 프로토콜로, 웹 브라우저와 서버 간 실시간 통신을 위해 설계된 웹 표준입니다.

*   소켓과 포트의 차이가 무엇인가요?
> - 포트는 하나의 호스트 내에서 여러 네트워크 서비스나 프로세스를 구분하기 위한 논리적 주소입니다.
> - 소켓은 네트워크 통신의 끝점(endpoint)으로, IP 주소와 포트 번호의 조합으로 구성되는 통신 인터페이스입니다.

*   여러 소켓이 있다고 할 때, 그 소켓의 포트 번호는 모두 다른가요?
포트 번호는 하나의 호스트내에서 고유하지만, 하나의 프로세스는 여러 개의 소켓을 열 수 있으므로 같은 IP, 같은 포트수를 가지고 있다 하더라도 여러 개의 소켓이 존재할 수 있습니다. 이에 따라 여러 소켓의 포트 번호가 같을 수 있습니다.
포트 번호가 같은 예시: 온라인 게임 서버는 수천 명의 플레이어가 동시에 서버에 접속하지만, 서버의 동일한 포트에서 접속한다. 게임 서버는 각 플레이어와의 연결을 별도의 소켓으로 관리한다.

*   사용자의 요청이 무수히 많아지면, 소켓도 무수히 생성되나요?
> - 사용자의 요청이 증가함에 따라 서버가 처리해야 하는 소켓도 증가한다. 다만 고려 사항이 있다.
> - 각 클라이언트 요청은 일반적으로 소켓을 생성하지만, 서버는 동시에 처리할 수 있는 소켓의 수에 제한이 있다. 따라서 대규모로 사용자 요청이 증가하는 경우, 서버는 소켓 풀링, 비동기 처리, 로드 밸런싱(부하 분산)과 같은 기술을 사용하여 효율적으로 요청을 처리하고 리소스를 관리해야 한다.

### 6\. HTTP/1.1과 HTTP/2의 차이점은 무엇인가요?
> - **HTTP/1.1**
>   - 연결당 단일 요청: 하나의 TCP 연결에서 하나의 요청과 응답만을 처리합니다. 따라서 페이지의 여러 리소스를 요청할 경우, 각각의 요청에 대해 별도의 연결을 열어야 하므로 성능에 제한이 있습니다.
>   - HOL(Head-of-Line) Blocking: 요청은 순차적으로 처리되므로, 앞선 요청이 지연되면 뒤의 모든 요청도 대기하게 되는 문제가 발생합니다.
>   - 헤더 비효율성: 각 요청마다 같은 헤더를 반복적으로 보내야 하며, 이는 데이터 낭비를 초래합니다.

> - **HTTP/2**
>   - 멀티플렉싱: 하나의 TCP 연결에서 여러 요청과 응답을 동시에 처리합니다. 애플리케이션 계층에서의 HOL Blocking을 해결하여 성능을 크게 향상시킵니다.
>   - 헤더 압축: HPACK 압축 방식을 사용하여 요청과 응답 헤더를 효율적으로 압축, 효율성을 높입니다.
>   - 서버 푸시: 서버는 클라이언트의 요청 없이도 필요한 리소스를 미리 전송할 수 있어 페이지 로딩 속도를 개선합니다.

*   HOL Blocking 에 대해 설명해 주세요.
> - HOL (Head-of-line) Blocking은 데이터 패킷 전송 시 앞에 있는 패킷이 처리되지 않으면 뒤의 패킷도 처리되지 않는 현상입니다. HTTP/1.1에서는 하나의 연결에서 요청이 순차적으로 처리되기 때문에, 하나의 요청이 대기 중일 경우 나머지 요청도 모두 대기 상태에 빠지게 됩니다.
> - HTTP/2이 지원하는 멀티플렉싱 기능은 한 연결에서 여러 요청을 병렬로 처리할 수 있기 때문에 애플리케이션 레벨에서 HOL Blocking 문제를 해결합니다. 하지만 TCP 프로토콜 특성상 Transport Layer에서는 HOL Blocking이 발생합니다. HTTP/3.0은 이를 QUIC을 통해 해결했습니다.

*   HTTP/3.0의 주요 특징에 대해 설명해 주세요.
> - HTTP/3.0은 QUIC(Quick UDP Internet Connections) 프로토콜을 기반으로 만들어졌습니다.
> - UDP 기반: QUIC은 TCP를 대체하는 범용 목적으로 개발된 4계층 통신 프로토콜로, UDP 위에서 동작합니다. TCP의 3-way handshake를 생략하고, 0-RTT(Round Trip Time) 연결을 지원하여 연결 설정 시간을 크게 단축합니다.
> - 0-RTT 연결: 첫 연결 시 데이터를 즉시 전송할 수 있습니다.
> - HOL Blocking 해결: HTTP/2가 해결하지 못했던 TCP 계층에서의 HOL Blocking 문제를 해결합니다. QUIC은 패킷 손실 시 해당 스트림(stream)만 영향을 받고, 다른 스트림은 정상적으로 작동합니다.
> - 강화된 보안: QUIC은 TLS 1.3을 내장하고 있어 보안성이 향상되었습니다.

### 7\. TCP와 UDP의 차이에 대해 설명해 주세요.
> * TCP:
>   - 연결 지향: 3-way handshake를 통한 연결 설정, 4-way handshake를 통한 연결 해제
>   - 신뢰성 보장: 순서 보장, 오류 검출 및 재전송, 중복 제거
>   - 흐름 제어: 수신자의 처리 능력에 맞춰 전송 속도 조절
>   - 혼잡 제어: 네트워크 상황에 따른 전송량 조절
>   - 전이중 통신: 양방향 동시 데이터 전송
>   - 사용 예: HTTP/HTTPS, FTP, SMTP 등
> * UDP (User Datagram Protocol):
>   - 비연결 지향: 연결 설정 없이 즉시 데이터 전송
>   - 신뢰성 미보장: 순서 보장 없음, 오류 검출만 수행(재전송 없음)
>   - 빠른 전송: 오버헤드가 적어 실시간성 중요한 애플리케이션에 적합
>   - 단순한 구조: TCP 대비 헤더 크기가 작음(8바이트 vs 20바이트)
>   - 사용 예: DNS, DHCP, 실시간 스트리밍, 온라인 게임 등

*   Checksum이 무엇인가요?
> - 체크섬(Checksum)은 데이터 전송 중 발생할 수 있는 오류를 검출하기 위한 방식입니다. 송신자는 데이터를 전송할 때 해당 데이터를 일정한 방식으로 계산하여 체크섬 값을 생성하고, 수신자는 이 체크섬을 이용해 데이터가 올바르게 전송되었는지 확인합니다.

*   TCP와 UDP 중 어느 프로토콜이 Checksum을 수행할까요?
> - TCP와 UDP 모두 Checksum을 수행합니다. TCP에서는 필수적이고, UDP는 선택적입니다. UDP에서 checksum을 쓰지 않는다면, checksum 부분을 전부 0으로 체웁니다.

*   그렇다면, Checksum을 통해 오류를 정정할 수 있나요?
> Checksum은 오류 발생 여부만 확인할 수 있다. 오류를 정정할 수 없고, 오류가 검출되면 송신 측에 재전송을 요청해 오류를 처리합니다.

*   TCP가 신뢰성을 보장하는 방법에 대해 설명해 주세요.
> - 세그먼트 번호: 데이터의 순서를 보장합니다.
> - 확인 응답(ACK): 송신자는 데이터를 전송한 후, 수신자가 해당 데이터를 받았다는 확인을 보냅니다.
> - 재전송: 응답이 오지 않으면 일정 시간 후 데이터를 재전송합니다.
> - 흐름 제어: 수신자의 버퍼가 오버플로우하지 않도록 데이터 전송 속도를 조절합니다.
> - 혼잡 제어: 네트워크가 혼잡할 때 전송 속도를 조절하여 혼잡을 피합니다.

*   TCP의 혼잡 제어 처리 방법에 대해 설명해 주세요.
> 슬로우 스타트(Slow Start), 혼잡 회피(Congestion Avoidance), 빠른 재전송(Fast Retransmit), 빠른 회복(Fast Recovery)

*   왜 HTTP는 TCP를 사용하나요?
> HTTP는 신뢰성 있는 데이터 전송이 필요합니다. TCP는 연결 지향적이고, 오류를 검출하고 수정할 수 있는 기능을 제공하기 때문에 HTTP에서 사용됩니다. 데이터가 순서대로 정확하게 전달되도록 보장합니다.

*   그렇다면, 왜 HTTP/3 에서는 UDP를 사용하나요? 위에서 언급한 UDP의 문제가 해결되었나요?
> UDP는 연결 설정이 빨라 HOL Blocking 문제를 해결할 수 있습니다.

*   그런데, 브라우저는 어떤 서버가 TCP를 쓰는지 UDP를 쓰는지 어떻게 알 수 있나요?
> 브라우저는 서버와의 초기 핸드쉐이크를 통해 사용되는 프로토콜을 알 수 있습니다. HTTP/1.1과 HTTP/2는 TCP를 사용하지만, HTTP/3는 QUIC 프로토콜을 사용하며 UDP 기반으로 동작합니다. 브라우저는 서버의 HTTP/3 지원 여부를 확인하고, 이를 통해 프로토콜을 선택합니다.

*   본인이 새로운 통신 프로토콜을 TCP나 UDP를 사용해서 구현한다고 하면, 어떤 기준으로 프로토콜을 선택하시겠어요?
> 프로토콜을 선택할 때 중요한 기준은:
> 신뢰성: 데이터의 정확한 전달이 필요한 경우 TCP를 사용합니다.
> 속도: 빠른 전송 속도가 필요한 경우 UDP를 사용합니다.
> 연결 설정 및 유지: 연결 설정을 최소화하고자 하면 UDP가 유리할 수 있습니다.
> 애플리케이션의 특성: 실시간 스트리밍, 게임 등에서는 UDP가 선호될 수 있고, 파일 전송, 웹 페이지 요청 등에서는 TCP가 필요합니다.

### 8\. DHCP가 무엇인지 설명해 주세요.
> DHCP는 네트워크상의 호스트들에게 IP 주소 및 네트워크 구성 정보를 자동으로 할당하는 네트워크 서비스 프로토콜입니다.
> * 주요 기능:
> - 자동 IP 주소 할당: 사용 가능한 IP 주소 풀에서 클라이언트에게 동적 할당
> - 네트워크 설정 제공: 서브넷 마스크, 기본 게이트웨이, DNS 서버 주소 등 설정 정보 전달
> - 주소 임대 관리: IP 주소 사용 기간(lease time) 관리 및 갱신
> * DHCP 동작 과정 (DORA 프로세스):
> - Discover: 클라이언트가 브로드캐스트로 DHCP 서버 탐색
> - Offer: DHCP 서버가 사용 가능한 IP 주소와 설정 정보 제안
> - Request: 클라이언트가 특정 서버의 제안을 선택하여 요청
> - Acknowledge: 서버가 IP 주소 할당을 확정하고 임대 정보 전송 -->

*   DHCP는 몇 계층 프로토콜인가요?
> DHCP는 애플리케이션 계층 프로토콜입니다. 네트워크에서 IP 주소를 동적으로 할당하는 프로토콜로, 보통 UDP를 사용하여 동작합니다.

*   DHCP는 어떻게 동작하나요?
> - DHCP Discover: 클라이언트는 DHCP 서버를 찾기 위해 브로드캐스트 메시지를 보냅니다.
> - DHCP Offer: 서버는 사용 가능한 IP 주소를 제시하며 응답합니다.
> - DHCP Request: 클라이언트는 서버에 IP 주소 할당을 요청합니다.
> - DHCP Acknowledge: 서버는 요청을 승인하고, 클라이언트에게 IP 주소를 할당합니다.

*   DHCP에서 UDP를 사용하는 이유가 무엇인가요?
> - 연결 지향적이지 않은 프로토콜이기 때문에 UDP를 사용합니다. UDP는 빠르고 간단한 통신을 제공하며, 연결을 설정할 필요가 없으므로 효율적입니다.

*   DHCP에서, IP 주소 말고 추가로 제공해주는 정보가 있나요?
> - 서브넷 마스크, 기본 게이트웨이, DNS 서버 등의 네트워크 설정 정보를 제공합니다.

*   DHCP의 유효기간은 얼마나 긴가요?
> - DHCP 유효기간(임대 기간)은 DHCP 서버에 의해 설정되며, 일반적으로 24시간에서 몇 일 정도로 설정됩니다. 클라이언트는 주기적으로 IP 주소 갱신을 요청할 수 있습니다.

### 9\. IP 주소는 무엇이며, 어떤 기능을 하고 있나요?
> - IP(Internet Protocol Address) 주소는 네트워크 상에서 장치나 호스트를 식별하는 고유한 숫자 주소입니다.
> - 주요 기능:
>   - 장치 식별: 네트워크상의 각 호스트를 유일하게 구분
>   - 라우팅: 데이터 패킷이 목적지까지 전달될 수 있도록 경로 정보 제공
>   - 네트워크 계층화: 네트워크 부분과 호스트 부분으로 구분하여 효율적인 주소 관리

*   IPv6는 IPv4의 주소 고갈 문제를 해결하기 위해 만들어졌지만, 아직도 수많은 기기가 IPv4를 사용하고 있습니다. 고갈 문제를 어떻게 해결할 수 있을까요?
> - IPv6는 IPv4의 주소 고갈 문제를 해결하기 위해 설계되었으며, 주소 공간이 거의 무한에 가까운 크기를 제공합니다. 그러나 IPv4와 IPv6의 호환성 문제, 기존 인프라의 전환 비용 등으로 인해 여전히 IPv4가 널리 사용되고 있습니다. NAT(Network Address Translation)와 같은 기술을 통해 IPv4 주소 고갈을 완화할 수 있으며, IPv6로의 전환을 촉진하는 것이 중요합니다.

*   IPv4와 IPv6의 차이에 대해 설명해 주세요.
> - IPv4는 32비트 주소 체계를 사용하여 약 43억 개의 주소를 지원합니다. IPv6는 128비트 주소 체계를 사용하여 사실상 무한에 가까운 수의 주소를 지원합니다. IPv6는 주소 공간이 더 크고, 자동 구성 기능, 보안성 강화 등의 장점이 있습니다.

*   수많은 사람들이 유동 IP를 사용하고 있지만, 수많은 공유기에서는 고정 주소를 제공하는 기능이 이미 존재합니다. 어떻게 가능한 걸까요?
> - 유동 IP는 ISP에서 할당하는 임시 주소이지만, 고정 IP는 사용자가 요청하면 지속적으로 같은 주소를 제공하는 방식입니다. 공유기에서는 DHCP 서버를 통해 내부 네트워크에서 고정 주소를 설정할 수 있습니다. 이는 특정 장치에 대해 고정 IP를 할당하는 방식으로 작동합니다.

*   IPv4를 사용하는 장비와 IPv6를 사용하는 같은 네트워크 내에서 통신이 가능한가요? 가능하다면 어떤 방법을 사용하나요?
> - IPv4와 IPv6는 기본적으로 호환되지 않지만, IPv6-to-IPv4 변환 기술이나 터널링을 통해 통신할 수 있습니다. Dual Stack 방식으로 동일한 장비가 IPv4와 IPv6 주소를 모두 지원하면 두 프로토콜 간의 통신이 가능합니다.

*   IP가 송신자와 수신자를 정확하게 전송되는 것을 보장해 주나요?
> - IP는 데이터의 전송 경로를 지정할 수 있지만, 전송이 완료되는지, 정확한 순서로 도달하는지를 보장하지 않습니다. 이를 보장하는 것은 TCP 프로토콜입니다.

*   IPv4에서 수행하는 Checksum과 TCP에서 수행하는 Checksum은 어떤 차이가 있나요?
> - IPv4 Checksum은 헤더만 검증하는 반면, TCP Checksum은 데이터와 헤더 모두를 검증합니다.

*   TTL(Hop Limit)이란 무엇인가요?
> - TTL(Time to Live)은 패킷이 네트워크를 통과할 수 있는 최대 홉 수를 지정합니다. TTL 값이 0이 되면 패킷은 폐기됩니다.

*   IP 주소와 MAC 주소의 차이에 대해 설명해 주세요.
> - IP 주소는 네트워크에서 논리적이고 라우팅 가능한 주소입니다. MAC 주소는 물리적이고 고유한 장치 식별자입니다. IP 주소는 네트워크에서 통신을 위해 사용되며, MAC 주소는 로컬 네트워크에서 장치를 식별하는 데 사용됩니다.

### 10\. OSI 7계층에 대해 설명해 주세요.

*   Transport Layer와, Network Layer의 차이에 대해 설명해 주세요.
*   L3 Switch와 Router의 차이에 대해 설명해 주세요.
*   각 Layer는 패킷을 어떻게 명칭하나요? 예를 들어, Transport Layer의 경우 Segment라 부릅니다.
*   각각의 Header의 Packing Order에 대해 설명해 주세요.
*   ARP에 대해 설명해 주세요.

### 11\. 3-Way Handshake에 대해 설명해 주세요.

*   ACK, SYN 같은 정보는 어떻게 전달하는 것 일까요?
*   2-Way Handshaking 를 하지않는 이유에 대해 설명해 주세요.
*   두 호스트가 동시에 연결을 시도하면, 연결이 가능한가요? 가능하다면 어떻게 통신 연결을 수행하나요?
*   SYN Flooding 에 대해 설명해 주세요.
*   위 질문과 모순될 수 있지만, 3-Way Handshake의 속도 문제 때문에 이동 수를 줄이는 0-RTT 기법을 많이 적용하고 있습니다. 어떤 방식으로 가능한 걸까요?

### 12\. 4-Way Handshake에 대해 설명해 주세요.

*   패킷이 4-way handshake 목적인지 어떻게 파악할 수 있을까요?
*   빨리 끊어야 할 경우엔, (즉, 4-way Handshake를 할 여유가 없다면) 어떻게 종료할 수 있을까요?
*   4-Way Handshake 과정에서 중간에 한쪽 네트워크가 강제로 종료된다면, 반대쪽은 이를 어떻게 인식할 수 있을까요?
*   왜 종료 후에 바로 끝나지 않고, TIME\_WAIT 상태로 대기하는 것 일까요?

### 13\. www.github.com을 브라우저에 입력하고 엔터를 쳤을 때, 네트워크 상 어떤 일이 일어나는지 최대한 자세하게 설명해 주세요.

*   DNS 쿼리를 통해 얻어진 IP는 어디를 가리키고 있나요?
*   Web Server와 Web Application Server의 차이에 대해 설명해 주세요.
*   URL, URI, URN은 어떤 차이가 있나요?

### 14\. DNS에 대해 설명해 주세요.

*   DNS는 몇 계층 프로토콜인가요?
*   UDP와 TCP 중 어떤 것을 사용하나요?
*   DNS Recursive Query, Iterative Query가 무엇인가요?
*   DNS 쿼리 과정에서 손실이 발생한다면, 어떻게 처리하나요?
*   캐싱된 DNS 쿼리가 잘못 될 수도 있습니다. 이 경우, 어떻게 에러를 보정할 수 있나요?
*   DNS 레코드 타입 중 A, CNAME, AAAA의 차이에 대해서 설명해주세요.
*   hosts 파일은 어떤 역할을 하나요? DNS와 비교하였을 때 어떤 것이 우선순위가 더 높나요?

### 15\. SOP 정책에 대해 설명해 주세요.

*   CORS 정책이 무엇인가요?
*   Preflight에 대해 설명해 주세요.

### 16\. Stateless와 Connectionless에 대해 설명해 주세요.

*   왜 HTTP는 Stateless 구조를 채택하고 있을까요?
*   Connectionless의 논리대로면 성능이 되게 좋지 않을 것으로 보이는데, 해결 방법이 있을까요?
*   TCP의 keep-alive와 HTTP의 keep-alive의 차이는 무엇인가요?

### 17\. 라우터 내의 포워딩 과정에 대해 설명해 주세요.

*   라우팅과 포워딩의 차이는 무엇인가요?
*   라우팅 알고리즘에 대해 설명해 주세요.
*   포워딩 테이블의 구조에 대해 설명해 주세요.

### 18\. 로드밸런서가 무엇인가요?

*   L4 로드밸런서와, L7 로드밸런서의 차이에 대해 설명해 주세요.
*   로드밸런서 알고리즘에 대해 설명해 주세요.
*   로드밸런싱 대상이 되는 장치중 일부 장치가 문제가 생겨 접속이 불가능하다고 가정해 봅시다. 이 경우, 로드밸런서가 해당 장비로 요청을 보내지 않도록 하려면 어떻게 해야 할까요?
*   로드밸런서 장치를 사용하지 않고, DNS를 활용해서 유사하게 로드밸런싱을 하는 방법에 대해 설명해 주세요.

### 19\. 서브넷 마스크와, 게이트웨이에 대해 설명해 주세요.

*   NAT에 대해 설명해 주세요.
*   서브넷 마스크의 표현 방식에 대해 설명해 주세요.
*   그렇다면, 255.0.255.0 같은 꼴의 서브넷 마스크도 가능한가요?

### 20\. 멀티플렉싱과 디멀티플렉싱에 대해 설명해 주세요.

*   디멀티플렉싱의 과정에 대해 설명해 주세요.

### 21\. XSS에 대해서 설명해 주세요.

*   CSRF랑 XSS는 어떤 차이가 있나요?
*   XSS는 프론트엔드에서만 막을 수 있나요?