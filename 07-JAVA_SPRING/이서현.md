\## Java, Spring

### 1\. JVM이 정확히 무엇이고, 어떤 기능을 하는지 설명해 주세요.
>   JVM(Java Virtual Machine)은 자바 바이트코드를 실행하는 가상 머신입니다. (=자바 프로그램의 실행 환경. 플랫폼 독립성 보장.)
>   주 기능: 바이트코드 로딩 (ClassLoader), 바이트코드 검증 (Bytecode Verifier), 바이트코드 실행 (인터프리터 + JIT 컴파일), 메모리 관리 (GC 포함), 스레드, 예외 처리 등 런타임 지원,

*   그럼, 자바 말고 다른 언어는 JVM 위에 올릴 수 없나요?
>   처음에는 자바만 JVM에서 실행되었지만, 시간이 지나며 다양한 언어들이 JVM 위에서 실행되도록 설계되었습니다. 대표적으로 Kotlin, Scala, Groovy 등이 있으며, 이들은 모두 자바처럼 JVM 바이트코드로 컴파일되어 동일한 런타임 환경에서 실행됩니다.

*   반대로 JVM 계열 언어를 일반적으로 컴파일해서 사용할 순 없나요?
> JVM 언어는 일반적으로 바이트코드로 컴파일되어 JVM 위에서 실행됩니다. 네이티브 바이너리로 직접 실행되려면 GraalVM 등 별도 AOT 컴파일러가 필요합니다.

*   VM을 사용함으로써 얻을 수 있는 장점과 단점에 대해 설명해 주세요.
> **1. 장점**
> - 플랫폼 독립성 확보 (WORA)
> - GC, 예외 처리 등 런타임 지원
> - JIT 최적화를 통한 실행 성능 향상
> - 보안성과 안정성 제공
> 
> **2. 단점**
> - 초기 실행 지연 및 메모리 오버헤드
> - 네이티브보다 낮은 성능
> - 시스템 자원 접근 제한
> - 실시간 처리나 저수준 프로그래밍에 부적합
> 

*   JVM과 내부에서 실행되고 있는 프로그램은 부모 프로세스 - 자식 프로세스 관계를 갖고 있다고 봐도 무방한가요?
> 아닙니다. 일반적으로 JVM 프로세스가 단일 사용자 프로세스이고, 애플리케이션은 그 안에서 실행되는 '쓰레드 단위의 논리적 실행'입니다. 따서 OS 관점에서는 하나의 JVM 프로세스일 뿐, 애플리케이션은 그 안의 코드입니다.

### 2\. final 키워드를 사용하면, 어떤 이점이 있나요?
> final은 불변성을 보장함으로써 코드의 안정성과 명확성을 높이고, 컴파일러나 JIT 컴파일러의 최적화를 가능하게 합니다.
> - 변수에 사용 시: 값 재할당을 방지하여 사이드 이펙트 없는 안전한 코드 작성 가능
> - 메서드에 사용 시: 오버라이딩을 방지하여 의도하지 않은 다형성 오용을 차단
> - 클래스에 사용 시: 상속 자체를 막아 설계의 고정성과 보안성 강화
> - 성능 측면: JIT 컴파일러가 final 메서드나 클래스에 대해 인라인 최적화를 적용할 수 있어 실행 속도 향상에 기여

*   그렇다면 컴파일 과정에서, final 키워드는 다르게 취급되나요?
> final 키워드는 컴파일러와 JVM/JIT에서 다르게 취급됩니다.
> 1. 컴파일러(javac) 수준
> - final 변수는 컴파일 타임 상수로 간주되어 코드에 값이 직접 인라인됨
> - final 메서드/클래스는 오버라이딩/상속 불가 검사를 통해 코드 안정성 보장
> 2. JVM 및 JIT 컴파일러 수준
> - final 메서드는 오버라이딩 불가능하므로 인라인 최적화 가능
> - final 클래스는 타입이 고정되어 가상 메서드 호출 제거 등의 최적화 가능

### 3\. 인터페이스와 추상 클래스의 차이에 대해 설명해 주세요.
> 인터페이스와 추상 클래스는 모두 '추상화'를 위한 도구지만, 추상화의 방식과 목적이 다릅니다.
> - 인터페이스는 구현과 무관하게 행위(기능)만을 추상화하며, 객체가 어떤 **능력(can-do)**을 갖고 있는지를 표현합니다. 서로 다른 계층이나 도메인에서도 공통 기능을 통합할 수 있도록 해주며, 다형성과 유연한 설계에 유리합니다.
> - 추상 클래스는 **공통된 상태(필드)와 행위(메서드)**를 묶어 부분 구현된 상위 타입을 정의할 때 사용합니다. 즉, is-a 관계가 명확한 계층 구조에서 사용되며, 구체 클래스 간의 구현 공유가 목적입니다.

*   왜 클래스는 단일 상속만 가능한데, 인터페이스는 2개 이상 구현이 가능할까요?
> 클래스는 **상태(필드)**와 **구현(메서드)**을 모두 가지므로 다중 상속 시 멤버 충돌이나 **상속 경로 모호성(MRO, Method Resolution Order)** 문제가 발생할 수 있습니다(다이아몬드 상속 문제). 반면 인터페이스는 원칙적으로 구현 없이 메서드 시그니처만 정의하므로 충돌 가능성이 낮아 다중 구현이 허용됩니다. Java 8 이후 default 메서드가 도입되었지만, 충돌 발생 시 명시적으로 해결하도록 강제함으로써 여전히 다중 구현이 가능합니다.

### 4\. 리플렉션에 대해 설명해 주세요.
> 리플렉션은 런타임에 클래스의 메타데이터에 접근해 클래스의 메서드, 타입, 필드 등의 정보를 조회/조작할 수 있는 자바 API입니다. (->구체적인 클래스 타입을 알지 못해도 접근 가능)

*   의미만 들어보면 리플렉션은 보안적인 문제가 있을 가능성이 있어보이는데, 실제로 그렇게 생각하시나요? 만약 그렇다면, 어떻게 방지할 수 있을까요?
> 리플렉션은 접근 제어자를 무시하고 private 멤버에 접근하는 등 보안 정책을 우회할 수 있다는 보안상 취약점이 있습니다. (클래스로더 조작 가능)

> 보안 위험 방지 방법:
> * SecurityManager 설정으로 리플렉션 접근 제한
> * 모듈 시스템(Java 9+)에서 exports 제한
> * 런타임에 필요한 최소한의 권한만 부여

*   리플렉션을 언제 활용할 수 있을까요?
> * Spring의 의존성 주입
> * JPA의 엔티티 매핑
> * JSON 직렬화/역직렬화
> * 단위 테스트에서 private 메서드 테스트
> IDE에서 Getter, Setter 자동 생성  기능

### 5\. static class와 static method를 비교해 주세요.
> static class는 중첩 클래스에서만 사용이 가능하고, 외부 클래스 인스턴스 없이 생성할 수 있습니다. 외부 클래스를 참조할 수 없습니다.
> static method는 어떤 클래스에서든 사용이 가능하고, 클래스 인스턴스 없이 호출할 수 있습니다. 인스턴스 변수에 접근할 수 없습니다.

*   static을 사용하면 어떤 이점을 얻을 수 있나요? 어떤 제약이 걸릴까요?
> static 사용 이점: 메모리에 한 번만 로드되므로 메모리 효율성 높음, 객체 생성 없이 접근 가능해 접근 속도 빠름 -> 공통 기능 제공, 유틸리티 함수 구현에 적합
> static 사용 시 제약: 인스턴스 변수나 메서드 접근 불가, 오버라이딩 불가, 상속 시 숨김 처리 (this. super 키워드 사용 불가하며 다형성 구현 제한)

*   컴파일 과정에서 static 이 어떻게 처리되는지 설명해 주세요.
> 1. 컴파일러가 static 멤버를 클래스 레벨로 바인딩
> 2. 바이트코드에서 invokestatic 명령어 생성
> 3. 런타임에 클래스 로더가 Method Area에 로드 (클래스와 같이 로딩)

### 6\. Java의 Exception에 대해 설명해 주세요.
> Java는 Exception은 프로그램 실행 중 발생할 수 있는 예외 상황을 나타내는 객체입니다. Throwable 클래스를 상속받습니다.

*   예외처리를 하는 세 방법에 대해 설명해 주세요.
> (1) 예외 복구, (2) 예외 회피, (3) 예외 전환

*   CheckedException, UncheckedException 의 차이에 대해 설명해 주세요.
> * Checked Exception: 컴파일러가 처리를 강제하여 컴파일 시점에 반드시 try catch 등으로 처리해야 하는 예외.
>   - Exception 클래스를 상속하는 예외 중 RuntimeException을 상속하지 않는 예외 (IOException, SQLException 등)
>   - try-catch 블록이나, throws 키워드를 사용하여 예외를 처리하도록 명시해야
> * Unchecked Exception: 런타임에 발생하며 처리가 선택적인 예외.
>   - RuntimeException을 상속하는 예외 (NullPointerException, IllegalArgumentException 등)
>   - 주로 개발자의 실수 혹은 논리 오류로 발생, 컴파일러가 처리를 강제하지 않으나 예외 처리 시 프로그램 안정성을 높일 수 있음.

*   예외처리가 성능에 큰 영향을 미치나요? 만약 그렇다면, 어떻게 하면 부하를 줄일 수 있을까요?
> 예외 발생 시 예외 객체 생성 비용에 들어 성능이 저하됩니다. (정상적인 흐름에서 예외를 사용하면 비효율적)
> * 성능 최적화 방법:
>   - 예외를 제어 흐름으로 사용하지 않기
>   - 미리 정의된 예외 객체 재사용
>   - 검증 로직으로 예외 발생 최소화
>   - fillInStackTrace() 오버라이드로 스택 트레이스 생성 생략

### 7\. Synchronized 키워드에 대해 설명해 주세요.
> Synchronized는 여러 스레드가 동시에 접근하는 것을 제어하여 스레드 안전성을 보장하는 Java의 키워드입니다. 내부적으로 모니터 락(Monitor Lock)을 통해 상호 배제를 구현합니다.

*   Synchronized 키워드가 어디에 붙는지에 따라 의미가 약간씩 변화하는데, 각각 어떤 의미를 갖게 되는지 설명해 주세요.
> 메서드에 붙으면 인스턴스/클래스 전체를 락으로 사용하고, 블록에 붙으면 지정한 객체를 락으로 사용합니다.

*   효율적인 코드 작성 측면에서, Synchronized는 좋은 키워드일까요?
> Synchronized는 간단하지만 성능상 제약이 있습니다. 블로킹 방식이고 세밀한 제어가 어려워 상황에 따라 다른 동기화 기법도 고려해야 합니다.

*   Synchronized 를 대체할 수 있는 자바의 다른 동기화 기법에 대해 설명해 주세요.
> • ReentrantLock: 더 세밀한 제어, 타임아웃 설정 가능
> • ReadWriteLock: 읽기/쓰기 락 분리
> • Atomic 클래스: Lock-free 알고리즘 사용
> • ConcurrentCollections: 동시성 컬렉션
> • Semaphore: 리소스 개수 제한

*   Thread Local에 대해 설명해 주세요.
> ThreadLocal은 각 스레드마다 독립적인 변수 복사본을 제공하는 클래스입니다. 스레드 간 데이터 공유 없이 스레드별로 고유한 데이터를 저장할 수 있습니다. 메모리 누수 주의가 필요합니다. (remove() 호출)

### 8\. Java Stream에 대해 설명해 주세요.
> Stream은 Java 8부터 도입된 함수형 프로그래밍 스타일로 컬렉션을 처리할 수 있는 API입니다. 데이터의 흐름을 추상화하여 선언적으로 데이터를 처리할 수 있게 해줍니다.
> Stream의 특징:
> • 함수형 프로그래밍: 람다식과 메서드 참조 사용
> • 지연 평가(Lazy Evaluation): 종료 연산이 호출될 때까지 중간 연산 지연
> • 내부 반복: 컬렉션의 반복을 Stream이 담당
> • 불변성: 원본 데이터 변경하지 않음
> • 일회용: 한 번 사용하면 재사용 불가

*   Stream과 for ~ loop의 성능 차이를 비교해 주세요.
> 일반적으로 단순한 반복에서는 for loop이 더 빠릅니다. 복잡한 데이터 처리나 병렬 처리에서는 Stream이 유리할 수 있습니다.

*   Stream은 병렬처리 할 수 있나요?
> parallelStream() 메서드나 parallel() 메서드를 사용하여 병렬 처리가 가능합니다. 그러나 스레드 안전하지 않은 연산 주의해야 하고, 작은 데이터셋에서는 오히려 성능이 저하될 수 있습니다.

*   Stream에서 사용할 수 있는 함수형 인터페이스에 대해 설명해 주세요.
> • Predicate<T>: boolean test(T t) - 조건 검사 (filter)
> • Function<T, R>: R apply(T t) - 변환 (map)
> • Consumer<T>: void accept(T t) - 소비 (forEach)
> • Supplier<T>: T get() - 공급 (generate)
> • BinaryOperator<T>: T apply(T t1, T t2) - 결합 (reduce)
> • Comparator<T>: int compare(T o1, T o2) - 비교 (sorted)

*   가끔 외부 변수를 사용할 때, final 키워드를 붙여서 사용하는데 왜 그럴까요? 꼭 그래야 할까요?
> 람다식에서는 effectively final 변수만 캡처할 수 있기 때문입니다. 이는 클로저의 안전성과 동시성 문제를 방지하기 위한 제약입니다.

### 9\. Java의 GC에 대해 설명해 주세요.
> > Garbage Collection(GC)은 JVM이 자동으로 사용하지 않는 메모리를 회수하는 메커니즘입니다. 프로그래머가 명시적으로 메모리를 해제할 필요가 없게 해줍니다.
> GC의 동작 원리:
> • Mark: 루트 객체로부터 참조되는 객체들을 표시
> • Sweep: 표시되지 않은 객체들을 메모리에서 제거
> • Compact: 메모리 단편화 해결을 위한 압축 (선택적)
> 메모리 영역:
> • Young Generation: Eden, Survivor0, Survivor1
> • Old Generation: 오래 살아남은 객체들
> • Permanent/Metaspace: 클래스 메타데이터 저장

*   finalize() 를 수동으로 호출하는 것은 왜 문제가 될 수 있을까요?
> finalize() 메서드의 수동 호출은 예측 불가능한 동작과 성능 문제를 야기할 수 있습니다. GC의 정상적인 동작을 방해할 수도 있습니다. -> Java 9부터 finalize()가 deprecated되었습니다. finalize() 대신 try-with-resources나 명시적 close() 사용을 권장합니다.

*   어떤 변수의 값이 null이 되었다면, 이 값은 GC가 될 가능성이 있을까요?
> 해당 객체를 참조하는 다른 변수가 있는지 여부가 중요합니다.
> GC 대상이 되는 조건:
> • 도달 불가능(Unreachable): 루트 객체로부터 참조 경로가 없음
> • 참조 카운트 0: 해당 객체를 가리키는 참조가 모두 사라짐
> • Strong Reference 없음: WeakReference만 남은 경우

### 10\. equals()와 hashcode()에 대해 설명해 주세요.
> equals()는 두 객체가 논리적으로 동등한지 판단하는 메서드입니다. hashCode()는 객체의 해시값을 반환하는 메서드입니다. 둘 다 Object 클래스에 정의되어 있으며, Hash 기반 컬렉션에서 중요한 역할을 합니다.

*   본인이 hashcode() 를 정의해야 한다면, 어떤 점을 염두에 두고 구현할 것 같으세요?
> 해시 충돌을 최소화하고 균등한 분산을 위해 equals()에서 사용하는 필드들을 활용하여 구현하겠습니다.
> 구현 시 고려사항:
> 1. equals()가 true를 반환하는 객체는 반드시 동일한 hashCode() 값을 가져야 합니다.
> 2. 동일한 객체에 대해 애플리케이션 실행 중 항상 같은 값을 반환해야 합니다.
> 3. 서로 다른 객체에 대해 가능하면 다른 해시 값을 반환하여 해시 충돌을 최소화해야 합니다.

*   그렇다면 equals() 를 재정의 해야 할 때, 어떤 점을 염두에 두어야 하는지 설명해 주세요.
> equals() 메서드는 동치관계의 특성을 만족하도록 구현해야 하며, hashCode()와의 일관성을 유지해야 합니다.
> equals() 계약 조건:
> • 반사성(Reflexive): x.equals(x)는 항상 true
> • 대칭성(Symmetric): x.equals(y)가 true이면 y.equals(x)도 true
> • 이행성(Transitive): x.equals(y)와 y.equals(z)가 true이면 x.equals(z)도 true
> • 일관성(Consistent): 객체가 변경되지 않았다면 여러 번 호출해도 같은 결과
> • null 처리: x.equals(null)은 항상 false
> 구현 시 주의사항:
> • instanceof 연산자로 타입 체크
> • 자기 자신과의 비교 먼저 확인
> • 핵심 필드들을 순서대로 비교
> • Float, Double은 compare() 메서드 사용
> • 배열 필드는 Arrays.equals() 사용

### 11\. IoC와 DI에 대해 설명해 주세요.
> IoC(Inversion of Control)는 제어의 역전을 의미하며, 객체의 생성과 생명주기 관리를 개발자가 아닌 컨테이너가 담당하는 설계 원칙입니다. DI(Dependency Injection)는 IoC를 구현하는 구체적인 방법 중 하나입니다.
> IoC(제어의 역전):
> • 전통적 방식: 객체가 직접 의존성을 생성하고 관리
> • IoC 방식: 외부 컨테이너가 객체 생성과 의존성 주입을 담당
> • 장점: 결합도 감소, 테스트 용이성, 유연성 증가
> DI(의존성 주입):
> • Constructor Injection: 생성자를 통한 주입
> • Setter Injection: Setter 메서드를 통한 주입
> • Field Injection: 필드에 직접 주입 (@Autowired)

*   후보 없이 특정 기능을 하는 클래스가 딱 한 개라면, 구체 클래스를 그냥 사용해도 되지 않나요? 그럼에도 불구하고 왜 Spring에선 Bean을 사용 할까요?
> 미래의 확장성, 테스트 용이성, AOP 적용, 생명주기 관리 등을 위해 

*   Spring의 Bean 생성 주기에 대해 설명해 주세요.
> • Bean 인스턴스 생성: 기본 생성자 호출
> • 의존성 주입: 프로퍼티 설정, @Autowired 처리
> • BeanNameAware: Bean 이름 설정
> • BeanFactoryAware: BeanFactory 설정
> • ApplicationContextAware: ApplicationContext 설정
> • BeanPostProcessor.postProcessBeforeInitialization(): 초기화 전 처리
> • @PostConstruct / InitializingBean.afterPropertiesSet(): 초기화
> • BeanPostProcessor.postProcessAfterInitialization(): 초기화 후 처리
> • Bean 사용 준비 완료
> • @PreDestroy / DisposableBean.destroy(): 소멸 처리

*   프로토타입 빈은 무엇인가요?
> 프로토타입 빈은 요청할 때마다 새로운 인스턴스를 생성하는 빈입니다. 기본적인 싱글톤 빈과 달리 매번 다른 객체가 반환됩니다.

### 12\. AOP에 대해 설명해 주세요.
> AOP, 관점 지향 프로그래밍('Aspect-Oriented Programming')은 흩어져있고 반복되는 공통 기능(관심사, Aspect)을 핵심 비즈니스 로직에서 분리하여 모듈화하고 재사용성을 높이는 프로그래밍 방법론입니다.
> * 관점 지향이란 어떤 로직을 핵심적인 관점, 부가적인 관점으로 나누어서 보고 그 관점을 기준으로 각각 모듈화하는 것을 말합니다.
> * 흩어진 관심사(Crosscutting Concerns): 소스 코드상에서 다른 부분에 계속 반복해서 쓰는 코드들.
>   * 핵심 기능과 별개로 관리해야 하는 '부가적인 관심사' 예시: 로깅, 보안, 트랜잭션 처리 등
> * AOP 주요 개념
>   * Aspect: 흩어진 관심사를 모듈화 한 것. 주로 부가기능을 모듈화함.
>   * Target: Aspect를 적용하는 곳
>   * Advice: 실질적으로 어떤 일을 해야할 지에 대한 것, 실질적인 부가기능을 담은 구현체
>   * JointPoint : Advice가 적용될 위치, 끼어들 수 있는 지점. 메서드 진입 지점, 생성자 호출 시점, 필드에서 값을 꺼내올 때 등 다양한 시점에 적용가능
>   * PointCut : JointPoint의 상세한 스펙을 정의한 것. 더욱 구체적으로 Advice가 실행될 지점을 정할 수 있음
>   * 참고자료: https://engkimbs.tistory.com/entry/스프링AOP

*   @Aspect는 어떻게 동작하나요?
>   * @Aspect 어노테이션은 해당 클래스가 AOP의 Aspect임을 알리는 메타데이터입니다. Spring의 AOP 프록시 생성기가 이 정보를 읽어 Advice와 Pointcut을 적용할 수 있도록 합니다. @Aspect 자체가 스프링 빈을 등록하지는 않는데, AOP가 동작하려면 Aspect 클래스도 스프링이 관리하는 빈이어야 합니다. 일반적으로 @Component를 함께 붙여 컴포넌트 스캔에 포함시키거나, @Bean을 통해 명시적으로 빈으로 등록합니다.

### 13\. Spring 에서 Interceptor와 Servlet Filter에 대해 설명해 주세요.
>   * Interceptor는 스프링 컨텍스트에서 동작하는 기술로써, Dispatcher Servlet이 컨트롤러를 호출하기 전과 후에 요청과 응답을 참조하거나 가공할 수 있는 기능을 제공합니다. 스프링 컨테이너 영역에서 관리됩니다. 스프링 예외 처리기 구현시 예외를 서블릿까지 전달하지 않도록 처리하기 위해 사용 가능합니다.
>   * Servlet Filter는 J2EE 표준 스펙 기능으로 Dispatcher Servlet에 요청이 전달되기 전/후에 URL 패턴에 맞는 모든 요청에 대해 부가작업을 처리할 수 있는 기능을 제공합니다. 스프링 이전의 서블릿 영역에서 관리됩니다. 현재는 스프링 빈으로 등록이 가능합니다.(참고: https://mangkyu.tistory.com/221) Request/Response 객체를 바꿔치기해 넣는 것이 가능합니다.
> 참고자료:https://mangkyu.tistory.com/173

*   설명만 들어보면 인터셉터만 쓰는게 나아보이는데, 아닌가요? 필터는 어떤 상황에 사용 해야 하나요?
>   * 필터는 스프링과 무관하게 전역적으로 처리해야 하는 작업들을 처리할 수 있습니다. 대표적으로 보안 검사(XSS 등)를 수행하면 스프링 컨테이너까지 요청이 전달되지 못하고 차단되어 안정성을 더욱 높일 수 있습니다. 
>   * 또한 이미지/데이터 압축, 문자열 인코딩과 같이 웹 애플리케이션에 전반적으로 사용되는 기능을 구현하기에 적합합니다.

### 14\. DispatcherServlet의 역할에 대해 설명해 주세요.
>   * DispatcherServlet은 HTTP 프로토콜로 들어오는 모든 요청을 가장 먼저 받아 적합한 컨트롤러에 위임해주는 프론트 컨트롤러(Front Controller)입니다. (HTTP 요청들을 매핑된 컨트롤러로 배차해주는 역할을 수행하는 중앙 서블릿)
> 참고자료: https://mangkyu.tistory.com/18

*   여러 요청이 들어온다고 가정할 때, DispatcherServlet은 한번에 여러 요청을 모두 받을 수 있나요?
>   * DispatcherServlet은 기본적으로 한 번에 하나의 요청을 처리합니다. 다만 DispatcherServlet은 서블릿 컨테이너 내에서 동작하고, 서블릿 컨테이너(Tomcat)의 멀티스레드 환경 덕분에 여러 요청을 받아 처리하는 것이 가능합니다.

*   수많은 @Controller 를 DispatcherServlet은 어떻게 구분 할까요?
> HandlerMapping을 통해 @RequestMapping을 기반으로 요청을 처리할 컨트롤러 메서드를 찾습니다. HandlerMapping은 미리 정의된 URL 패턴과 컨트롤러 메서드를 매핑해 둔 맵핑 정보를 가지고 있으며, DispatcherServlet은 이 맵핑 정보를 참조하여 가장 적합한 컨트롤러를 찾고 해당 컨트롤러를 호출합니다.

### 15\. JPA와 같은 ORM을 사용하는 이유가 무엇인가요?
>   * ORM을 사용하는 이유는 객체-관계 불일치를 해결하고, 생산성과 유지보수성을 높이며, DB 독립성과 다양한 부가 기능을 제공해주기 때문입니다.
>   * 구체적 설명:
>       * 객체-관계 불일치 해결: 자바 애플리케이션은 객체 지향, DB는 관계형 모델을 사용 → 불일치(O/R impedance mismatch) 발생. ORM이 객체와 테이블 매핑을 자동화하여 중복 코드(조회, 저장, 매핑) 줄임.
>       * 데이터베이스 독립성: JPA는 JPQL/HQL 등 추상화된 쿼리 사용 → DBMS 교체 시 영향 최소화. Dialect만 바꾸면 다른 DB에서도 동작.

*   영속성은 어떤 기능을 하나요? 이게 진짜 성능 향상에 큰 도움이 되나요?
>   * JPA에서 영속성(persistence)은 엔티티를 영속성 컨텍스트에서 관리하는 것을 의미합니다. 영속성 컨텍스트의 주요 기능이 성능 향상에 도움이 되는 방식을 설명하겠습니다.
>   (1) 1차 캐시 사용: 동일한 트랜잭션 내에서 데이터베이스에 대한 중복 요청을 줄여 성능을 향상시킵니다.
>   (2) 쓰기 지연 저장소 사용: 메모리에 임시로 저장된 변경 사항을 한 번에 처리함으로써 데이터베이스의 부하를 줄입니다.
>   (3) 변경 감지: JPA에서 엔티티의 상태가 변경될 때마다 UPDATE SQL이 쓰기 지연 저장소에 저장된다면, 비효율적인 상황이 발생할 수 있습니다. JPA는 변경 감지를 통해 자동으로 엔티티의 현재 상태와 최초 상태를 비교하여 변경된 부분만을 포함하는 UPDATE SQL을 생성합니다. 이를 통해 효율적으로 데이터베이스에 반영할 수 있습니다.
>   (4) 엔티티 동일성 보장: 같은 트랜잭션 내에서 같은 PK를 가진 엔티티를 여러 번 조회하면, DB에서 매번 select 하지 않고 1차 캐시에서 동일 객체를 반환합니다. 이로써 중복 DB 조회를 제거하고, 객체 생성/관리 비용을 줄여 성능을 향상시킵니다.

*   N + 1 문제에 대해 설명해 주세요.
> * 1번의 쿼리를 날렸을 때 의도하지 않은 N번의 쿼리가 추가적으로 실행되는 것을 의미합니다. JPA Repository를 활용해 인터페이스 메소드를 호출할 때, 1:N 또는 N:1 관계를 가진 엔티티를 조회할 때 발생합니다.
> * 발생되는 상황: JPA Fetch 전략이 EAGER 전략으로 데이터를 조회하는 경우, JPA Fetch 전략이 LAZY 전략으로 데이터를 가져온 이후에 연관 관계인 하위 엔티티를 다시 조회하는 경우
> * 발생하는 이유: JPA Repository로 find 시 실행하는 첫 쿼리에서 하위 엔티티까지 한 번에 가져오지 않고, 하위 엔티티를 사용할 때 추가로 조회하기 때문에. 

### 16\. @Transactional 은 어떤 기능을 하나요?
> * @Transactional은 스프링에서 트랜잭션의 시작, 커밋, 롤백을 자동으로 관리해주는 어노테이션입니다. 메서드 실행 시 트랜잭션을 열고, 정상 종료되면 커밋, 예외 발생 시 롤백 처리합니다. 전파, 격리 수준, 예외별 롤백 정책 등을 제어할 수 있습니다.

*   @Transactional(readonly=true) 는 어떤 기능인가요? 이게 도움이 되나요?
> readOnly = true 옵션을 주면 JPA에서 변경 감지를 하지 않아 스냅샷을 만들지 않고, 일부 DB에서는 읽기 전용 트랜잭션으로 최적화됩니다(MySQL은 아님). 따라서 조회 성능이 개선되고 불필요한 리소스를 줄일 수 있습니다. 대규모 조회나 조회 전용 서비스에서 도움이 됩니다.

*   그런데, 읽기에 트랜잭션을 걸 필요가 있나요? @Transactional을 안 붙이면 되는거 아닐까요?
> JPA 환경에서는 읽기에도 트랜잭션을 걸어주는 것이 안전합니다.
>   * JPA는 엔티티 매니저가 트랜잭션 안에서만 Lazy Loading을 지원합니다.
>   * DB 드라이버 레벨에서 데이터베이스 격리 수준에 따라 일관성 있는 읽기(스냅샷)을 보장하려면 트랜잭션이 필요합니다. (ex. Repeatable Read 같은 격리 수준에서 동일 트랜잭션 내 조회 결과 일관성 유지)

### 17\. Java 에서 Annotation 은 어떤 기능을 하나요?
> Annotation은 자바 코드에 메타데이터를 제공하는 기능입니다. 클래스, 메서드, 필드 등에 부가 정보를 붙여 컴파일러, 런타임, 프레임워크가 이를 읽고 특정 동작을 수행할 수 있게 합니다. 예를 들어, @Override는 컴파일러에게 오버라이딩 검증을 요청하고, @Autowired, @Transactional 같은 스프링 애노테이션은 런타임 시 AOP나 DI 같은 기능을 적용합니다. 결국 애노테이션은 코드에 직접 로직을 넣지 않고 선언적으로 동작을 제어하는 방식입니다. (자바 컴파일러 인식용 vs 런타임 처리용 종류 다름)

*   별 기능이 없는 것 같은데, 어떻게 Spring 에서는 Annotation 이 그렇게 많은 기능을 하는 걸까요?
> Annotation 자체는 단순히 메타데이터일 뿐이고 실행 로직을 가지지 않습니다. Spring은 리플렉션(Reflection) + 프록시 + AOP를 통해 Annotation 정보를 읽고, 그에 맞는 동작을 수행합니다.
즉, Annotation은 '표시'이고, 실제 동작은 스프링 컨테이너나 프레임워크 코드가 해석해서 구현하는 구조입니다.

*   Lombok의 @Data를 잘 사용하지 않는 이유는 무엇일까요?
> * Setter 남용: @Data를 사용하면 id 필드도 setter가 생성되기 때문에 안정성을 보장 받을 수 없게 됩니다.
> * @RequiredArgsConstructor 어노테이션으로 인한 문제: 동일 타입 필드 순서가 바뀐 경우 에러가 발생하지 않아 디버깅이 어렵습니다.
> * 참고자료: https://ddururiiiiiii.tistory.com/369

### 18\. Tomcat이 정확히 어떤 역할을 하는 도구인가요?
> Tomcat은 자바 기반 동적 웹 애플리케이션 실행 환경을 제공하는 서블릿 컨테이너(Servlet Container)이자 경량 웹 애플리케이션 서버(WAS)입니다. 클라이언트로부터 HTTP 요청을 받아 서블릿이나 JSP 같은 자바 웹 컴포넌트를 실행하고, 그 결과를 HTTP 응답으로 돌려줍니다.

*   혹시 Netty에 대해 들어보셨나요? 왜 이런 것을 사용할까요?
> Netty는 비동기 이벤트 기반의 네트워크 애플리케이션 프레임워크입니다. 자바 NIO(Non-blocking I/O)를 추상화하여 고성능 네트워크 서버나 클라이언트를 쉽게 개발할 수 있도록 돕습니다.